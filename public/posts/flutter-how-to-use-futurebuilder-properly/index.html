<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>How to use Flutter’s FutureBuilder properly | exavolt&#39;s rambling</title>
<meta name="keywords" content="">
<meta name="description" content="When developing a Flutter app, there might be a need to display data that are not instantly available. This data needs to be prepared asynchronously to prevent freezing of the app. And while the data is being prepared, we want to display an indicator so that users know that their data is being loaded.
Fortunately, the Flutter framework has FutureBuilder widget that fits well for this use case.
The official documentation does provide explanations on how to use the FutureBuilder, but I find that turning it into a set of practical rules makes it easier to follow.">
<meta name="author" content="">
<link rel="canonical" href="https://example.org/posts/flutter-how-to-use-futurebuilder-properly/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://example.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://example.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://example.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://example.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://example.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://example.org/posts/flutter-how-to-use-futurebuilder-properly/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:title" content="How to use Flutter’s FutureBuilder properly" />
<meta property="og:description" content="When developing a Flutter app, there might be a need to display data that are not instantly available. This data needs to be prepared asynchronously to prevent freezing of the app. And while the data is being prepared, we want to display an indicator so that users know that their data is being loaded.
Fortunately, the Flutter framework has FutureBuilder widget that fits well for this use case.
The official documentation does provide explanations on how to use the FutureBuilder, but I find that turning it into a set of practical rules makes it easier to follow." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://example.org/posts/flutter-how-to-use-futurebuilder-properly/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-06-20T02:54:27+00:00" />
<meta property="article:modified_time" content="2024-06-20T02:54:27+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="How to use Flutter’s FutureBuilder properly"/>
<meta name="twitter:description" content="When developing a Flutter app, there might be a need to display data that are not instantly available. This data needs to be prepared asynchronously to prevent freezing of the app. And while the data is being prepared, we want to display an indicator so that users know that their data is being loaded.
Fortunately, the Flutter framework has FutureBuilder widget that fits well for this use case.
The official documentation does provide explanations on how to use the FutureBuilder, but I find that turning it into a set of practical rules makes it easier to follow."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://example.org/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "How to use Flutter’s FutureBuilder properly",
      "item": "https://example.org/posts/flutter-how-to-use-futurebuilder-properly/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "How to use Flutter’s FutureBuilder properly",
  "name": "How to use Flutter’s FutureBuilder properly",
  "description": "When developing a Flutter app, there might be a need to display data that are not instantly available. This data needs to be prepared asynchronously to prevent freezing of the app. And while the data is being prepared, we want to display an indicator so that users know that their data is being loaded.\nFortunately, the Flutter framework has FutureBuilder widget that fits well for this use case.\nThe official documentation does provide explanations on how to use the FutureBuilder, but I find that turning it into a set of practical rules makes it easier to follow.",
  "keywords": [
    
  ],
  "articleBody": "When developing a Flutter app, there might be a need to display data that are not instantly available. This data needs to be prepared asynchronously to prevent freezing of the app. And while the data is being prepared, we want to display an indicator so that users know that their data is being loaded.\nFortunately, the Flutter framework has FutureBuilder widget that fits well for this use case.\nThe official documentation does provide explanations on how to use the FutureBuilder, but I find that turning it into a set of practical rules makes it easier to follow.\nThe problematic usage The FutureBuilder has some requirements which if not satisfied it won’t work correctly. The following is an example widget that utilizes a FutureBuilder the wrong way. While it might work in some cases, it might cause issues in other cases. Can you spot the where the part that might cause problems?\nclass ShowcaseView extends StatelessWidget { @override void build(BuildContext context) { return FutureBuilder( future: fetchProductList(), builder: ( BuildContext context, AsyncSnapshot\u003cProductList\u003e snapshot, ) { /* Build the content */ } ); } } The part that might cause problems is where the future is obtained, that is within the build method.\nBut why it’s wrong to obtain or create the future during build?\nIn the example above, depending on the implementation of fetchProductList, the future might get recreated when the widget gets rebuilt. Recreating a future on every build might cause some problems:\nThe widget will simply not work, i.e., the data from the completed future will never get displayed because the future keeps being recreated Unnecessarily wasting server’s resources if the future involves fetching data from the server Unnecessarily drain device’s battery if the future involves some heavy, on-device, computations The last two above can cause bad user experiences My rules to reliably utilize FutureBuilders Make the widget a StatefulWidget because a FutureBuilder can only work in a StatefulWidget widget\nDeclare the future as an instance variable (a.k.a. property, attribute, member) of the state class\nObtain the future in the initState method, never during the build\nUse the declared instance variable as the parameter for the FutureBuilder in the build method\n// Here's a skeleton for a widget that utilizes FutureBuilder at its // minimum. // 1. It must be a StatefulWidget class ShowcaseView extends StatefulWidget { /* ... */ } class _ShowcaseViewState extends State\u003cShowcaseView\u003e { // 2. Declare the future as an instance variable in the state class Future\u003cProductList\u003e? _productListFuture; @override void initState() { // 3. Obtain or create the future in the initState _productListFuture = fetchProductList(); } @override Widget build(BuildContext context) { return FutureBuilder( // 4. Use the future as the parameter to FutureBuilder future: _productListFuture, builder: ( BuildContext context, AsyncSnapshot\u003cProductList\u003e snapshot, ) { /* Build the future-dependent content */ } ); } } If the future is affected by any value passed as a parameter to the widget, ensure to override didUpdateWidget to re-create the future when the value changed.\n// 1. class ShowcaseView extends StatefulWidget { const ShowcaseView({ super.key, required this.storeId, }); // An example of future-affecting instance variable. // // In this example, the content of the showcase depends on the // store, which is specified by storeId. final String storeId; } class _ShowcaseViewState extends State\u003cShowcaseView\u003e { // 2. Future\u003cProductList\u003e? _productListFuture; @override void initState() { // 3. Note that the invocation has been updated to include instance variable from the widget. _productListFuture = fetchProductList(storeId: widget.storeId); } @override Widget build(BuildContext context) { return FutureBuilder( // 4. future: _productListFuture, builder: ( BuildContext context, AsyncSnapshot\u003cProductList\u003e snapshot, ) { /* Build the future-dependent content */ } ); } // 5. Override the method didUpdateWidget to conditionally re-obtain the future @override void didUpdateWidget(covariant ShowcaseView oldWidget) { super.didUpdateWidget(oldWidget); // 5a. Check if the value has changed if (widget.storeId != oldWidget.storeId) { // 5b. Obtain a new future if it did change _productListFuture = fetchProductList(storeId: widget.storeId); } } } If the state is listening to a listenable, determine whether a value change would require future recreation.\nThat’s all. The above rules should have covered common usages of FutureBuilder.\n",
  "wordCount" : "676",
  "inLanguage": "en",
  "datePublished": "2024-06-20T02:54:27Z",
  "dateModified": "2024-06-20T02:54:27Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://example.org/posts/flutter-how-to-use-futurebuilder-properly/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "exavolt's rambling",
    "logo": {
      "@type": "ImageObject",
      "url": "https://example.org/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://example.org/" accesskey="h" title="exavolt&#39;s rambling (Alt + H)">exavolt&#39;s rambling</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      How to use Flutter’s FutureBuilder properly
    </h1>
    <div class="post-meta"><span title='2024-06-20 02:54:27 +0000 UTC'>June 20, 2024</span>

</div>
  </header> 
  <div class="post-content"><p>When developing a Flutter app, there might be a need to display data that are not instantly available. This data needs to be prepared asynchronously to prevent freezing of the app. And while the data is being prepared, we want to display an indicator so that users know that their data is being loaded.</p>
<p>Fortunately, the Flutter framework has <code>FutureBuilder</code> widget that fits well for this use case.</p>
<p>The official documentation does provide explanations on how to use the <code>FutureBuilder</code>, but I find that turning it into a set of practical rules makes it easier to follow.</p>
<h2 id="the-problematic-usage">The problematic usage<a hidden class="anchor" aria-hidden="true" href="#the-problematic-usage">#</a></h2>
<p>The <code>FutureBuilder</code> has some requirements which if not satisfied it won&rsquo;t work correctly. The following is an example widget that utilizes a <code>FutureBuilder</code> the wrong way. While it might work in some cases, it might cause issues in other cases. Can you spot the where the part that might cause problems?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dart" data-lang="dart"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ShowcaseView</span> <span style="color:#66d9ef">extends</span> StatelessWidget {
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">@</span>override
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> build(BuildContext context) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> FutureBuilder(
</span></span><span style="display:flex;"><span>      future: fetchProductList(),
</span></span><span style="display:flex;"><span>      builder: (
</span></span><span style="display:flex;"><span>        BuildContext context,
</span></span><span style="display:flex;"><span>        AsyncSnapshot<span style="color:#f92672">&lt;</span>ProductList<span style="color:#f92672">&gt;</span> snapshot,
</span></span><span style="display:flex;"><span>      ) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Build the content */</span>
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The part that might cause problems is where the future is obtained, that is within the <code>build</code> method.</p>
<p>But why it&rsquo;s wrong to obtain or create the future during <code>build</code>?</p>
<p>In the example above, depending on the implementation of <code>fetchProductList</code>, the future might get recreated when the widget gets rebuilt. Recreating a future on every build might cause some problems:</p>
<ul>
<li>The widget will simply not work, i.e., the data from the completed future will never get displayed because the future keeps being recreated</li>
<li>Unnecessarily wasting server&rsquo;s resources if the future involves fetching data from the server</li>
<li>Unnecessarily drain device&rsquo;s battery if the future involves some heavy, on-device, computations</li>
<li>The last two above can cause bad user experiences</li>
</ul>
<h2 id="my-rules-to-reliably-utilize-futurebuilders">My rules to reliably utilize FutureBuilders<a hidden class="anchor" aria-hidden="true" href="#my-rules-to-reliably-utilize-futurebuilders">#</a></h2>
<ol>
<li>
<p>Make the widget a <code>StatefulWidget</code> because a <code>FutureBuilder</code> can only work in a <code>StatefulWidget</code> widget</p>
</li>
<li>
<p>Declare the future as an instance variable (a.k.a. property, attribute, member) of the state class</p>
</li>
<li>
<p>Obtain the future in the <code>initState</code> method, never during the <code>build</code></p>
</li>
<li>
<p>Use the declared instance variable as the parameter for the <code>FutureBuilder</code> in the <code>build</code> method</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dart" data-lang="dart"><span style="display:flex;"><span><span style="color:#75715e">// Here&#39;s a skeleton for a widget that utilizes FutureBuilder at its
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// minimum.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 1. It must be a StatefulWidget
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ShowcaseView</span> <span style="color:#66d9ef">extends</span> StatefulWidget { <span style="color:#75715e">/* ... */</span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_ShowcaseViewState</span> <span style="color:#66d9ef">extends</span> State<span style="color:#f92672">&lt;</span>ShowcaseView<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 2. Declare the future as an instance variable in the state class
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Future<span style="color:#f92672">&lt;</span>ProductList<span style="color:#f92672">&gt;?</span> _productListFuture;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">@</span>override
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> initState() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 3. Obtain or create the future in the initState
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    _productListFuture <span style="color:#f92672">=</span> fetchProductList();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">@</span>override
</span></span><span style="display:flex;"><span>  Widget build(BuildContext context) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> FutureBuilder(
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 4. Use the future as the parameter to FutureBuilder
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      future: _productListFuture,
</span></span><span style="display:flex;"><span>      builder: (
</span></span><span style="display:flex;"><span>        BuildContext context,
</span></span><span style="display:flex;"><span>        AsyncSnapshot<span style="color:#f92672">&lt;</span>ProductList<span style="color:#f92672">&gt;</span> snapshot,
</span></span><span style="display:flex;"><span>      ) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Build the future-dependent content */</span>
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p>If the future is affected by any value passed as a parameter to the widget, ensure to override <code>didUpdateWidget</code> to re-create the future when the value changed.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dart" data-lang="dart"><span style="display:flex;"><span><span style="color:#75715e">// 1.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ShowcaseView</span> <span style="color:#66d9ef">extends</span> StatefulWidget {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> ShowcaseView({
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">super</span>.key,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">required</span> <span style="color:#66d9ef">this</span>.storeId,
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// An example of future-affecting instance variable.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// In this example, the content of the showcase depends on the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// store, which is specified by storeId.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">String</span> storeId;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_ShowcaseViewState</span> <span style="color:#66d9ef">extends</span> State<span style="color:#f92672">&lt;</span>ShowcaseView<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 2.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Future<span style="color:#f92672">&lt;</span>ProductList<span style="color:#f92672">&gt;?</span> _productListFuture;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">@</span>override
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> initState() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 3. Note that the invocation has been updated to include instance variable from the   widget.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    _productListFuture <span style="color:#f92672">=</span> fetchProductList(storeId: widget.storeId);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">@</span>override
</span></span><span style="display:flex;"><span>  Widget build(BuildContext context) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> FutureBuilder(
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 4.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      future: _productListFuture,
</span></span><span style="display:flex;"><span>      builder: (
</span></span><span style="display:flex;"><span>        BuildContext context,
</span></span><span style="display:flex;"><span>        AsyncSnapshot<span style="color:#f92672">&lt;</span>ProductList<span style="color:#f92672">&gt;</span> snapshot,
</span></span><span style="display:flex;"><span>      ) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Build the future-dependent content */</span>
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 5. Override the method didUpdateWidget to conditionally re-obtain the future
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#960050;background-color:#1e0010">@</span>override
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> didUpdateWidget(covariant ShowcaseView oldWidget) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">super</span>.didUpdateWidget(oldWidget);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 5a. Check if the value has changed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (widget.storeId <span style="color:#f92672">!=</span> oldWidget.storeId) {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 5b. Obtain a new future if it did change
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      _productListFuture <span style="color:#f92672">=</span> fetchProductList(storeId: widget.storeId);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p>If the state is listening to a listenable, determine whether a value change would require future recreation.</p>
</li>
</ol>
<p>That&rsquo;s all. The above rules should have covered common usages of <code>FutureBuilder</code>.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://example.org/">exavolt&#39;s rambling</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
